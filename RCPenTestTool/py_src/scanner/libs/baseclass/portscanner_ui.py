import socket
import time

from threading import Lock, Thread

from kivy.logger import Logger
from kivy.properties import ObjectProperty
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.screenmanager import Screen

from kivymd.theming import ThemableBehavior
from kivymd.uix.button import MDFlatButton
from kivymd.uix.dialog import MDDialog
from kivymd.uix.list import OneLineAvatarIconListItem

from scanner_share import threaded

class IllegalPort(Exception):
    pass


class PortScannerConfigDialog(BoxLayout):
    pass


class PortScanner(ThemableBehavior, Screen):

    app = ObjectProperty()
    config_dialog = ObjectProperty()
    log_lock = Lock()

    def show_config_dialog(self):
        if not self.config_dialog:
            self.config_dialog = MDDialog(
                title="Scan Information:",
                type="custom",
                content_cls=PortScannerConfigDialog(),
                buttons=[
                    MDFlatButton(
                        text="CANCEL",
                        text_color=self.app.theme_cls.primary_color,
                        on_release=self.on_cancel
                    ),
                    MDFlatButton(
                        text="OK",
                        text_color=self.app.theme_cls.primary_color,
                        on_release=self.on_confirm
                    ),
                ],
            )
            self.config_dialog.md_bg_color = self.theme_cls.bg_dark
        self.config_dialog.open()

    def on_confirm(self, *args):
        self.config_dialog.dismiss()
        address     = self.config_dialog.content_cls.ids.address_text_field.text
        port_start  = self.config_dialog.content_cls.ids.port_start_text_field.text
        port_end    = self.config_dialog.content_cls.ids.port_end_text_field.text
        self.scan_ports(address, port_start, port_end)

    def on_cancel(self, *args):
        self.config_dialog.dismiss()

    def log_to_log_field(self, message):
        with self.log_lock:
            self.ids.log_field.text += '\n' + message
            self.ids.scroll_view.scroll_to(self.ids.bottom)

    @threaded
    def scan_ports(self, address, port_start, port_end):
        try:
            ip = socket.gethostbyname(address)
            port_start = self.parse_port(port_start)
            port_end = self.parse_port(port_end)
        except socket.gaierror as err:
            self.log_to_log_field("Failed to get ip from address \"{}\", err {}".format(address, err))
            return
        except IllegalPort as err:
            self.log_to_log_field("{}".format(err))
            return

        self.log_to_log_field("Start scanning {}({}):{}~{}".format(ip, address, port_start, port_end))
        start_time = time.time()

        threads = []
        for port in range(port_start, port_end+1):
            th = Thread(target=self.scan_port, args=(ip, port))
            th.start()
            threads.append(th)

        for th in threads:
            th.join()

        end_time = time.time()
        time_elapsed = end_time - start_time
        self.log_to_log_field("Done scanning {}({}):{}~{}, time elapsed {}".format(ip, address, port_start, port_end, time_elapsed))

    def parse_port(self, port_text):
        try:
            port = int(port_text)
        except ValueError as err:
            raise IllegalPort("Can't parse port from \"{}\", err {}".format(port_text, err))

        if port < 0 or port > 65535:
            raise IllegalPort("Port should be 0~65535, got {}".format(port_text))

        return port

    def scan_port(self, ip, port):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5)
            s.connect((ip, port))
            self.log_to_log_field("Port {} is open".format(port))
            s.close()
        except:
            pass
